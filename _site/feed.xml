<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:5000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:5000/" rel="alternate" type="text/html" /><updated>2022-12-10T17:22:26+09:00</updated><id>http://localhost:5000/feed.xml</id><title type="html">DevTM</title><subtitle>An dev website.</subtitle><author><name>Wakenhole</name></author><entry><title type="html">Basic Chapter 6. Understanding Performance Metric</title><link href="http://localhost:5000/avx/throughput-latency/" rel="alternate" type="text/html" title="Basic Chapter 6. Understanding Performance Metric" /><published>2022-11-23T00:00:00+09:00</published><updated>2022-11-23T00:00:00+09:00</updated><id>http://localhost:5000/avx/throughput%20latency</id><content type="html" xml:base="http://localhost:5000/avx/throughput-latency/">&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html#optimization&quot;&gt;Software Optimization Reference Manual&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.agner.org/optimize/&quot;&gt;Agner Fog’s Guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://uops.info/background.html&quot;&gt;μops&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://mediaspace.illinois.edu/media/t/1_j92uv9l2&quot;&gt;Pipeline Latency and Throughput&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;p&gt;일반적으로 Software의 성능은 cache miss, IO bandwidth, bus bandwidth 등에 영향을 받지만 여기서는 그 이외의 부분에 대해서 논의 한다. 
이를 통해서 instruction sequence의 chain latency를 최소화 할수 있는 방법을 이해할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;definition&quot;&gt;Definition&lt;/h2&gt;

&lt;p&gt;가장 중요한 두 정의는 아래와 같다.&lt;/p&gt;

&lt;h3 id=&quot;latency&quot;&gt;Latency&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;The number of clock cycles that are required for the execution core to complete the execution of all of the μops that form an instruction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;하나의 instruction을 구성하는 μops들을 수행 완료를 하는데 걸리는 시간이다. 즉 피연산자가 준비된 시점 부터 결과 데이터 도출되는데 까지 걸리는 clock cycle 수를 말한다.&lt;/p&gt;

&lt;p&gt;일반적으로는 다른 instruction과의 경쟁이 없는 상태에서 측정된 것이다.&lt;/p&gt;

&lt;h3 id=&quot;throughput&quot;&gt;Throughput&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;The number of clock cycles required to wait before the issue ports are free to accept the same instruction again. For many instructions, the throughput of an instruction can be significantly less than its latency.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Intel의 정의에 따르면, 하나의 instruction이 다시 수행을 하기 위해 필요한 clock cycle을 의미한다. 이는 흔히 reciprocal throughput 정의를 따르는데 이는 CPU의 pipeline과 instruction level prallelism를 고려하기 위함이다. 
즉, CPU pipeline에서 같은 instruction을 다시 수행하기 위한 시간이 1 cycle이라고 할지라도, 동시에 2개가 수행될 수 있으면 throughput은 0.5 cycle이다.
예를 들면, _mm512_add_epi16 가 0.5 cycle throughput을 가진다.&lt;/p&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;

&lt;p&gt;아래 그림은 latency와 cycle의 개념적인 의미를 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/2586880/203658732-b7c12a92-fcb2-402b-8d56-4145b6bd7783.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Instruction fetch (IF)
    &lt;ul&gt;
      &lt;li&gt;Get the next instruction.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Instruction decode &amp;amp; register fetch (ID)
    &lt;ul&gt;
      &lt;li&gt;Decode the instruction and get the registers from the register file.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Execution/effective address calculation (EX)
    &lt;ul&gt;
      &lt;li&gt;Perform the operation.
        &lt;ul&gt;
          &lt;li&gt;For load and stores, calculate the memory address (base + immed).&lt;/li&gt;
          &lt;li&gt;For branches, compare and calculate the branch destination.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Memory access/branch completion (MEM)
    &lt;ul&gt;
      &lt;li&gt;For load and stores, perform the memory access.&lt;/li&gt;
      &lt;li&gt;For taken branches, update the program counter.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Writeback (WB)
    &lt;ul&gt;
      &lt;li&gt;Write the result to the register file.&lt;/li&gt;
      &lt;li&gt;For stores and branches, do nothing.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Wakenhole</name></author><category term="AVX" /><category term="SIMD" /><category term="Programming" /><category term="Performance" /><summary type="html">Reference Software Optimization Reference Manual Agner Fog’s Guide μops Pipeline Latency and Throughput</summary></entry><entry><title type="html">Advanced Chapter 1. Load and Store</title><link href="http://localhost:5000/avx/Load-and-Store/" rel="alternate" type="text/html" title="Advanced Chapter 1. Load and Store" /><published>2022-11-22T00:00:00+09:00</published><updated>2022-11-22T00:00:00+09:00</updated><id>http://localhost:5000/avx/Load%20and%20Store</id><content type="html" xml:base="http://localhost:5000/avx/Load-and-Store/">&lt;h2 id=&quot;register--memory&quot;&gt;Register &amp;amp; Memory&lt;/h2&gt;
&lt;p&gt;AVX vectorize 구현시 가장 중요한 것은 Memory와 Register 관리 이다.
AVX 연산 자체는 빠르다고 하더라도, 이를 사용하기 위해서는 register에 load 해야 하고, 연산 후에 다시 memory에 저장해야 하기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;bad-example&quot;&gt;Bad example&lt;/h2&gt;

&lt;p&gt;예를 들면 A[16]+B[16] 덧셈을 element-wise 하기 위한 아래 예제를 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input_A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input_B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__m512i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_mm512_load_si512&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 8 cycle&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__m512i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_mm512_load_si512&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 8 cycle&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__m512i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_mm512_add_epi32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// 1 cycle&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_mm512_store_epi32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;output_A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 5 cycle&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;언듯 보기에는 잘 구현된 코드이지만, 실제 각 instrinsic에서 소모되는 cycle은 아래와 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;_mm512_load_si512&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;_mm512_add_epi32&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;_mm512_store_epi32&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;latency&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;8&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;throughput&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;0.5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;실제로 16개의 add 연산을 1 cycle에 처리한다고 하더라도 사용되는 cycle은 22 cycle이다. scalar level 연산을 1cycle이 가정하면 소모되는 16 cycle 보다 느리다는 의미이다. (scalar가 register load되는 시간 제외)
이 경우는 vectorize를 하지 않는 것이 오히려 바람직 할 수도 있다.&lt;/p&gt;

&lt;h2 id=&quot;good-example&quot;&gt;Good example&lt;/h2&gt;

&lt;p&gt;하지만 만약 A+B, A-B, B-A를 모두 구해야 하는 상황 이라면 아래와 같을 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input_A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input_B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ApB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AmB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BmA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__m512i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_mm512_load_si512&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 8 cycle&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__m512i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_mm512_load_si512&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 8 cycle&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__m512i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_mm512_add_epi32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// 1 cycle&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__m512i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_mm512_sub_epi32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// 1 cycle&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__m512i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_mm512_sub_epi32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// 1 cycle&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_mm512_store_epi32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ApB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 5 cycle&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_mm512_store_epi32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AmB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 5 cycle&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_mm512_store_epi32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BmA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 5 cycle&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;사용되는 total 34 cycle로 scalar에서 소모될 것으로 예상되는 48 cycle 보다 빠르다는 것을 알 수 있다. 
즉 한번 load한 후 다중 연산을 할 수 있도록 구성하는 것이 중요하다.&lt;/p&gt;</content><author><name>Wakenhole</name></author><category term="AVX" /><category term="SIMD" /><category term="Programming" /><category term="Optimization" /><summary type="html">Register &amp;amp; Memory AVX vectorize 구현시 가장 중요한 것은 Memory와 Register 관리 이다. AVX 연산 자체는 빠르다고 하더라도, 이를 사용하기 위해서는 register에 load 해야 하고, 연산 후에 다시 memory에 저장해야 하기 때문이다.</summary></entry><entry><title type="html">Basic Chapter 2. AVX Notations</title><link href="http://localhost:5000/avx/AVX-notations/" rel="alternate" type="text/html" title="Basic Chapter 2. AVX Notations" /><published>2022-11-20T00:00:00+09:00</published><updated>2022-11-20T00:00:00+09:00</updated><id>http://localhost:5000/avx/AVX%20notations</id><content type="html" xml:base="http://localhost:5000/avx/AVX-notations/">&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.codeproject.com/Articles/874396/Crunching-Numbers-with-AVX-and-AVX&quot;&gt;Crunching Numbers with AVX and AVX2&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;AVX는 기존 C++ programming과는 다른 용어들이 많이 존재하기 때문에 이에 대해서 알아보자.&lt;/p&gt;

&lt;h2 id=&quot;data-type-naming-rule&quot;&gt;Data type naming rule&lt;/h2&gt;
&lt;p&gt;기본적인 정의 방법은 다음과 같이 표시한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;__&amp;lt;bit_width&amp;gt;&amp;lt;data_type&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&amp;lt;ddd&amp;gt;는 bit수를 의미하며 128, 256, 512가 지원된다.&lt;/p&gt;

&lt;p&gt;&amp;lt;s&amp;gt;는 data type을 나타내며 i, d, empty가 있다. 
i는 integer type (bit수 무관), d는 double-precision 64 bit floating point, 비어있는 경우는 가장 기본인 single-precision 32 bit floating point 이다.
따라서 아래와 같은 조합이 가능하다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Data Type&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;__m128&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;128-bit vector containing 4 floats&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;__m128d&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;128-bit vector containing 2 doubles&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;__m128i&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;128-bit vector containing integers&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;__m256&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;256-bit vector containing 8 floats&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;__m256d&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;256-bit vector containing 4 doubles​&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;__m256i&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;256-bit vector containing integers&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;__m512&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;512-bit vector containing 16 floats&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;__m512d&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;512-bit vector containing 8 doubles​&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;__m512i&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;512-bit vector containing integers&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;instrinc-naming-rule&quot;&gt;Instrinc naming rule&lt;/h2&gt;
&lt;p&gt;기본적인 정의 방법은 다음과 같이 표시한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_mm&amp;lt;bit_width&amp;gt;_&amp;lt;operation&amp;gt;_&amp;lt;data_type&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 포맷은 아래와 같이 구성된다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&amp;lt;bit_width&amp;gt;: return 되는 (때로는 사용되는) bit 수를 의미한다. 128인 경우는 해당 영역이 비어있다.&lt;/li&gt;
  &lt;li&gt;&amp;lt;operation&amp;gt;: 일종의 함수 이름으로 instrinsc operation을 나타낸다.&lt;/li&gt;
  &lt;li&gt;&amp;lt;data_type&amp;gt;: instrinsic의 primary argument의 데이터 타입이며, 대략적인 종류는 아래와 같다.&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Data Type&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;ph&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;em&gt;p&lt;/em&gt;acked &lt;em&gt;h&lt;/em&gt;alf-precision floating point (16 bits)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;ps&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;em&gt;p&lt;/em&gt;acked &lt;em&gt;s&lt;/em&gt;ingle-precision floating point (32 bits)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;pd&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;em&gt;p&lt;/em&gt;acked &lt;em&gt;d&lt;/em&gt;ouble-precision floating point (64 bits)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;epi8/epi16/epi32/epi64&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8/16/32/64 bits &lt;em&gt;e&lt;/em&gt;xtended &lt;em&gt;p&lt;/em&gt;acked signed integers&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;epu8/epu16/epu32/epu64&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8/16/32/64 bits &lt;em&gt;e&lt;/em&gt;xtended &lt;em&gt;p&lt;/em&gt;acked unsigned integers&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;si128/si256/si512&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;unspecified 128/256/512 bits vector&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;앞선 예제에서 살펴봤던 아래 구현은 16bit integer 32개를 add operation 한 후 512 bit vector를 return 하는 함수이다.&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;__m512i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_mm512_add_epi16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1 instrinsic is used&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;register&quot;&gt;Register&lt;/h2&gt;

&lt;p&gt;AVX 512는 xmm, ymm, zmm 3가지 종류의 register를 제공한다. 
아래의 그림과 같이 bit length가 각각 128, 256, 512 이다. ymm은 xmm 두개로 구성되며, zmm은 ymm 두개로 구성된다.&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;img src=&quot;https://cvw.cac.cornell.edu/vector/images/registers_updated.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Registery&lt;/em&gt;&lt;/p&gt;</content><author><name>Wakenhole</name></author><category term="AVX" /><category term="SIMD" /><category term="Programming" /><category term="Notations" /><summary type="html">Reference Crunching Numbers with AVX and AVX2 AVX는 기존 C++ programming과는 다른 용어들이 많이 존재하기 때문에 이에 대해서 알아보자.</summary></entry><entry><title type="html">Introduction To AVX</title><link href="http://localhost:5000/avx/Introduction-to-AVX/" rel="alternate" type="text/html" title="Introduction To AVX" /><published>2022-11-19T00:00:00+09:00</published><updated>2022-11-19T00:00:00+09:00</updated><id>http://localhost:5000/avx/Introduction%20to%20AVX</id><content type="html" xml:base="http://localhost:5000/avx/Introduction-to-AVX/">&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cs.cmu.edu/afs/cs/academic/class/15213-s19/www/lectures613/04-simd.pdf&quot;&gt;SIMD basic&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html&quot;&gt;Intel Instrinsics Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;single-instruction-multiple-datasimd&quot;&gt;Single Instruction Multiple Data(SIMD)&lt;/h2&gt;

&lt;p&gt;데이터 처리 속도를 높이기 위해 병렬처리 (Parallel processing) 기법을 많이 사용한다. 흔히 많이 알고 있는 방법은 CPU core level에서 
여러 multiple process or thread를 생성해서 multiple core를 동시에 (simultaneously) 활용하여 처리하는 방식이다. 
하지만 SIMD는 CPU core level 동작이 아닌 data level에서 병렬 처리를 위해 등장한 vectorize 기술로 여러 데이터에데서 반복적인 동일한 연산을 처리하는데 주로 사용된다.&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/2586880/202849587-f7b398be-7a9f-48c4-86bf-36220830f322.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Scalar&lt;/em&gt;&lt;/p&gt;

&lt;p class=&quot;image-caption&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/2586880/202849607-9e44e4d8-3107-4dfa-808f-22b8100b53ba.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SIMD&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;simple-example&quot;&gt;Simple Example&lt;/h2&gt;

&lt;p&gt;실제로 구현 예제는 아래와 같다. 
32 bits integer 16개를 덧셈 연산하는 것이다. 
__m512i라는 변수는 512 bits (32*16)을 저장하고 있다고 보면된다. 
16개의 덧셈 동작을 한번에 처리 할 수 있으므로 연산속도가 약 16배 빨라진다고 생각할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 16 instrinsics are used&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;__m512i&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_mm512_add_epi16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1 instrinsic is used&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Wakenhole</name></author><category term="AVX" /><category term="SIMD" /><category term="Programming" /><summary type="html">Reference SIMD basic Intel Instrinsics Guide</summary></entry><entry><title type="html">Undefined Behavior</title><link href="http://localhost:5000/programming/Undefined-Behavior/" rel="alternate" type="text/html" title="Undefined Behavior" /><published>2022-11-06T00:00:00+09:00</published><updated>2022-11-06T00:00:00+09:00</updated><id>http://localhost:5000/programming/Undefined%20Behavior</id><content type="html" xml:base="http://localhost:5000/programming/Undefined-Behavior/">&lt;h1 id=&quot;undefined-behavior-ub&quot;&gt;Undefined behavior (UB)&lt;/h1&gt;

&lt;p&gt;Complier는 최적화를 위해서 다양한 기법을 적용하는데, 이 결과로 기대한 결과와 다른 결과가 나올 수가 있다. 이러한 프로그램은 잘못 짠 프로그램으로 간주하고 compiler는 특별한 행동을 할 필요는 없다.&lt;/p&gt;
&lt;h2 id=&quot;overflow&quot;&gt;overflow&lt;/h2&gt;
&lt;p&gt;Singed overflow 문제로, compiler는 x+1 &amp;gt; x를 비교해서 return 하는 것이 아니라 그냥 true를 return 한다.&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// either true or UB due to signed overflow&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;foo(int):                                # @foo(int)
        movl    $1, %eax
        retq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Pointer arithmetic overflow 문제로, compiler는 p+a &amp;amp; p+b를 비교하는 것이 아니라 a와 b만 비교한다. 
gcc와 llvm의 차이가 있지만, 결과는 같다.&lt;/p&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;overflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;overflow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0xffffffff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;.clang
overflow(int*, int, int):                            # @overflow(int*, int, int)
        movl    %edx, %eax
        cmpl    %edx, %esi
        cmovgel %esi, %eax
        retq
.gcc
test(int*, int, int):
        movslq  %esi, %rsi
        movslq  %edx, %rcx
        movq    %rsi, %rax
        salq    $2, %rcx
        salq    $2, %rsi
        cmpq    %rcx, %rsi
        cmovle  %edx, %eax
        ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;notice--info&quot;&gt;&lt;a href=&quot;https://godbolt.org/z/zh45457bv&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;poison-value-deferred-ub&quot;&gt;Poison value: Deferred UB&lt;/h2&gt;
&lt;p&gt;p가 0xFFFFFFFF 일지라도 n=0이라면 문제가 없는 코드이다.
하지만 아래 코드와 같이 최적화를 할경우 undefined behavior가 발생한다. 
따라서 이런 당장 발생하지 않는 변수에 대해서 poision value라고 하고 eventually undefined behavior를 발생시킬 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// optimized&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Wakenhole</name></author><category term="Programming" /><category term="Optimization" /><category term="Undefined behavior" /><summary type="html">Undefined behavior (UB)</summary></entry><entry><title type="html">다주택 종합부동산세 계산법 예시</title><link href="http://localhost:5000/%EB%B6%80%EB%8F%99%EC%82%B0/%EC%A2%85%ED%95%A9%EB%B6%80%EB%8F%99%EC%82%B0%EC%84%B8-%EC%A4%91%EA%B3%BC%EC%84%B8/" rel="alternate" type="text/html" title="다주택 종합부동산세 계산법 예시" /><published>2022-09-04T00:00:00+09:00</published><updated>2022-09-04T00:00:00+09:00</updated><id>http://localhost:5000/%EB%B6%80%EB%8F%99%EC%82%B0/%EC%A2%85%ED%95%A9%EB%B6%80%EB%8F%99%EC%82%B0%EC%84%B8%20%EC%A4%91%EA%B3%BC%EC%84%B8</id><content type="html" xml:base="http://localhost:5000/%EB%B6%80%EB%8F%99%EC%82%B0/%EC%A2%85%ED%95%A9%EB%B6%80%EB%8F%99%EC%82%B0%EC%84%B8-%EC%A4%91%EA%B3%BC%EC%84%B8/">&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.getnews.co.kr/news/articleView.html?idxno=593758&quot;&gt;종합부동산세 기본 공제&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.nts.go.kr/nts/cm/cntnts/cntntsView.do?mi=2357&amp;amp;cntntsId=7739&quot;&gt;종합부동산세 안내 자료&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;개요&quot;&gt;개요&lt;/h2&gt;

&lt;p&gt;종합부동산세(종부세)는 매년 6월 1일 기준 부동산 보유자가 그 해 12월에 납부 한다. 계산법이 정책이 바뀜에 따라서 매우 복잡하게 바뀌어서 혼란스러운데, 특히 다른 재산세와 다르게 인별과세가 일부 항목에 한해서 적용된다는 점이 있다. 기본적인 과세 방법은 아래 식을 따른다.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
$종합부동산세 = 과세 표준 × 세율$
&lt;/p&gt;

&lt;h2 id=&quot;과세-표준&quot;&gt;과세 표준&lt;/h2&gt;
&lt;p&gt;과세 표준의 기본 계산법은 아래와 같으며 기본적으로 용도에 따라서 분리하여 과세 한다.&lt;/p&gt;

&lt;p&gt;$[\sum_{}^{} (공시가격 × (1-감면율)) - 공제금액)]  × 공정시장가액비율$&lt;/p&gt;

&lt;p&gt;주택의 종부세를 계산함에 있어서 중요한 것은 아래와 같으며, 정부 정책에 따라서 고정인 것과 변동이 있는 것으로 구분된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인별 과세(고정): 인당 보유한 주택 수와 공시가격의 합산이 중요하다.&lt;/li&gt;
  &lt;li&gt;공제 금액(변동): 공제금액은 기본 6억, 1세대 1주택 단독명의 경우 11억으로 공제 금액이 중가한다.&lt;/li&gt;
  &lt;li&gt;공정시장가액 비율(변동): 현재는 60%이나 정책에 따라서 가장 쉽게 변하는 것으로 2021년에는 95%였다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--info&quot;&gt;인별 과세와 유일하게 무관한 항목이 공제 금액으로 이는 &lt;strong&gt;가구별&lt;/strong&gt; 1주택 여부가 중요하다.&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;2022년 1세대에 1주택 단독 명의에 한해서 14억까지 증가시킨다는 이야기가 있지만 확정은 아니다.&lt;/p&gt;

&lt;h2 id=&quot;공동명의&quot;&gt;공동명의&lt;/h2&gt;

&lt;p&gt;종부세 전세를 위해서 공동 명의로 할 경우가 많았다. 이유는 기존에는 공제 금액이 1세대 1주택 단독명의의 경우 11억&lt;del&gt;9억&lt;/del&gt;, 1세대 1주택 부부 공동명의의 경우 각각 6억 해서 12억을 공제 받을 수 있었다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2021년 부터 단독명의의 경우 11억으로 증액되면서 공동명의의 혜택이 상대적으로 크게 줄었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;계산-예시&quot;&gt;계산 예시&lt;/h3&gt;
&lt;p&gt;즉 감면율이 없는 상태에서 12억 공시지가의 주택의 경우 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;단독명의 과세표준 = $[12 - 11 = 1억] × 공정시장가액비율$&lt;/li&gt;
  &lt;li&gt;공동명의의 과세표준 = $[12/2 - 6 = 0억] × 공정시장가액비율$
즉 공동명의의 경우 과세가 되지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;다만 2023년 부터 기본공제 금액도 9억으로 증액한다는 기조를 발표하였다. 따라서 국회를 통과하면 18억까지 세금이 없을 것으로 예상된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;세율&quot;&gt;세율&lt;/h2&gt;

&lt;p&gt;세율 산성에 있어서 가장 중요한 것은 인별 다주택 여부 이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://dimg.donga.com/wps/NEWS/IMAGE/2022/07/22/114578227.1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;즉, 2주택을 가지고 있는 경우 부부 개별 명의로 하면 인별 1주택이기 때문에 중과세 대상에서 제외되지만, 공동명의로 할 경우 인별 다주택이 되어서 세율이 중과된다.&lt;/p&gt;

&lt;p&gt;따라서 공동명의로 할 경우 공제금액에서 유리하고 개별 명의로 할 경우 중과세에서 유리하다.&lt;/p&gt;

&lt;h3 id=&quot;계산-예시-1&quot;&gt;계산 예시&lt;/h3&gt;

&lt;p&gt;만약 공시지가 20억 상당의 주택이 2개 있는 경우 대략적인 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;개별 명의: $[20 - 6 = 14억] × 0.6(공정시장가액) × 1.2(세율) × 2 (2채)$ = 약 2000만원&lt;/li&gt;
  &lt;li&gt;공동 명의: $[20 - 6 = 14억] × 0.6(공정시장가액) × 2.2(세율) × 2 (2명)$ = 약 3700만원&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;극단적으로 4인가족이 20억 1채 10억 2채를 가지고 있을 경우는 20억 물건에 대해서 2인 공동명의 10억 물건에 대해서는 각각 개별 명의로 진행 하는 것이 바람직하다. 이에 최근 증여가 크게 급증한 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;20억 물건: $[10 - 6 = 4억] × 0.6(공정시장가액) × 0.6(세율) × 2 (2명)$ = 약 288만원&lt;/li&gt;
  &lt;li&gt;10억 물건: $[10 - 6 = 4억] × 0.6(공정시장가액) × 0.6(세율) × 2 (2채)$ = 약 288만원&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉, 자산 배분을 어떻게 하느냐에 따라서 세금이 수천만원, 수억원 차이날 수 있다.&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;과세 표준 구간별 세금 및 제산새 중복분등이 고려해야 정확하다. 개념을 이해하기 위해서 간략화 한다. 실제는 저것의 약 70% 수준일 것이다.&lt;/p&gt;</content><author><name>Wakenhole</name></author><category term="부동산" /><category term="세금" /><category term="종합부동산세" /><summary type="html">Reference 종합부동산세 기본 공제 종합부동산세 안내 자료</summary></entry><entry><title type="html">용도 지역 이해하기</title><link href="http://localhost:5000/%EB%B6%80%EB%8F%99%EC%82%B0/%EC%9A%A9%EB%8F%84-%EC%A7%80%EC%97%AD/" rel="alternate" type="text/html" title="용도 지역 이해하기" /><published>2022-08-12T00:00:00+09:00</published><updated>2022-08-12T00:00:00+09:00</updated><id>http://localhost:5000/%EB%B6%80%EB%8F%99%EC%82%B0/%EC%9A%A9%EB%8F%84%20%EC%A7%80%EC%97%AD</id><content type="html" xml:base="http://localhost:5000/%EB%B6%80%EB%8F%99%EC%82%B0/%EC%9A%A9%EB%8F%84-%EC%A7%80%EC%97%AD/">&lt;h2 id=&quot;1-용도-지역&quot;&gt;1. 용도 지역&lt;/h2&gt;
&lt;p&gt;용도 지역은 아래와 같이 도시, 관리, 농림 자연환경 보전 지역으로 분류 할 수 있다. 용도 지역에 따라서 건축물의 용도 및 크기를 제한 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/27388F4B56C985A736&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://t1.daumcdn.net/cfile/tistory/232A7A455358AC6528&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-투자&quot;&gt;2. 투자&lt;/h2&gt;
&lt;p&gt;투지를 위해 적합한 지역은 아래와 같이 분류 할수 있다.&lt;/p&gt;

&lt;h3 id=&quot;단기-투자&quot;&gt;단기 투자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;도시지역 / 주거지역&lt;/li&gt;
  &lt;li&gt;도시지역 / 상업지역&lt;/li&gt;
  &lt;li&gt;도시지역 / 공업지역&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;장기-투자&quot;&gt;장기 투자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;도시지역 / 녹지지역 / 자연녹지지역&lt;/li&gt;
  &lt;li&gt;비도시지역 / 관리지역 / 계획관리지역&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자연녹지지역은 향후 주거, 상업, 공업지역으로 편입 가능성이 있고, 계획관리지역은 도시지역으로 편입될 가능성이 있다. 특히 자연녹지지역의 경우 제한적으로 개발이 가능하다 (건폐율 20% 용적률 100%).
하지만 경사도 임목도 등에 따라서 개발행위를 금하고 있기도 하기 때문에 확인이 필요하다.&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;용도 지역은 &lt;a href=&quot;https://www.eum.go.kr/&quot;&gt;토지e음&lt;/a&gt;에서 &lt;strong&gt;토지 이용 계획 열람&lt;/strong&gt;을 통해서 조회 가능하다.&lt;/p&gt;

&lt;h2 id=&quot;3-예제&quot;&gt;3. 예제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;주거지역
    &lt;ul&gt;
      &lt;li&gt;경기도 성남시 수정구 사송동 597-3번지&lt;/li&gt;
      &lt;li&gt;대지&lt;/li&gt;
      &lt;li&gt;도시지역 , 제1종일반주거지역 , 지구단위계획구역(GB 우선해제 샘골) , 소로3류(폭 8m 미만)(접합)&lt;/li&gt;
      &lt;li&gt;건폐율 60%&lt;/li&gt;
      &lt;li&gt;용적률 160%&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자연녹지지역
    &lt;ul&gt;
      &lt;li&gt;경기도 성남시 수정구 시흥동 38-1번지&lt;/li&gt;
      &lt;li&gt;대지&lt;/li&gt;
      &lt;li&gt;도시지역 , 자연녹지지역 , 자연취락지구 , 소로3류(폭 8m 미만)(접합)&lt;/li&gt;
      &lt;li&gt;건폐율 20%&lt;/li&gt;
      &lt;li&gt;용적률 100%&lt;/li&gt;
      &lt;li&gt;층수제한 4층&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-건폐율-용적률&quot;&gt;4. 건폐율 용적률&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.eum.go.kr/web/FileDownload.do?file=/20200828/regguide/rgregister/RgFacilityFormPopup.jsp/008_02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>Wakenhole</name></author><category term="부동산" /><category term="용도지역" /><category term="자연녹지지역" /><category term="계획관리지역" /><category term="건폐율" /><category term="용적율" /><summary type="html">1. 용도 지역 용도 지역은 아래와 같이 도시, 관리, 농림 자연환경 보전 지역으로 분류 할 수 있다. 용도 지역에 따라서 건축물의 용도 및 크기를 제한 한다.</summary></entry><entry><title type="html">건축 가능한 토지 지목 종류 이해하기</title><link href="http://localhost:5000/%EB%B6%80%EB%8F%99%EC%82%B0/%EA%B1%B4%EC%B6%95-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%86%A0%EC%A7%80-%EC%A7%80%EB%AA%A9-%EC%A2%85%EB%A5%98-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="건축 가능한 토지 지목 종류 이해하기" /><published>2022-08-11T00:00:00+09:00</published><updated>2022-08-11T00:00:00+09:00</updated><id>http://localhost:5000/%EB%B6%80%EB%8F%99%EC%82%B0/%EA%B1%B4%EC%B6%95%20%EA%B0%80%EB%8A%A5%ED%95%9C%20%ED%86%A0%EC%A7%80%20%EC%A7%80%EB%AA%A9%20%EC%A2%85%EB%A5%98%20%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:5000/%EB%B6%80%EB%8F%99%EC%82%B0/%EA%B1%B4%EC%B6%95-%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%86%A0%EC%A7%80-%EC%A7%80%EB%AA%A9-%EC%A2%85%EB%A5%98-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/">&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.naver.com/PostView.nhn?blogId=airvil&amp;amp;logNo=221931722416&amp;amp;categoryNo=12&amp;amp;parentCategoryNo=0&amp;amp;viewDate=&amp;amp;currentPage=1&amp;amp;postListTopCurrentPage=&amp;amp;from=thumbnailList&amp;amp;userTopListOpen=true&amp;amp;userTopListCount=30&amp;amp;userTopListManageOpen=false&amp;amp;userTopListCurrentPage=1&quot;&gt;토지 지목에 따른 활용 방법&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;지목의-종류&quot;&gt;지목의 종류&lt;/h2&gt;

&lt;p&gt;지목은 토지의 주된 사용 목적에 따라서 토지의 종류를 구분하는 명칭이다.
총 28개의 많은 종류가 있지만 알아야 하는 건축 지목은 전, 답, 임야, 대 크게 4가지 종류이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전: 밭으로 식물을 재배를 위한 토지&lt;/li&gt;
  &lt;li&gt;답: 논으로 물을 상시 이용이 필요한 토지&lt;/li&gt;
  &lt;li&gt;임야: 산림, 자갈 모래땅등을 말함&lt;/li&gt;
  &lt;li&gt;대: 건축물을 지을 수 있는 토지 (대지 증명원으로 확인 가능)&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--info&quot;&gt;나대지: 지목의 종류는 아니고, 대지 중 건축물이 없는 경우를 말함. 지목 변경비용이 들지 않기 때문에, 가장 선호되는 타입&lt;/p&gt;</content><author><name>Wakenhole</name></author><category term="부동산" /><category term="지목" /><category term="토지" /><summary type="html">Reference 토지 지목에 따른 활용 방법</summary></entry></feed>